<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五子棋</title>
    <style>
        :root {
            --board-bg: #eecfa1;
            --board-border: #d4a76a;
            --line-color: rgba(60, 40, 20, 0.4);
            --black-stone: radial-gradient(circle at 30% 30%, #666, #000);
            --white-stone: radial-gradient(circle at 30% 30%, #fff, #d1d1d1);
            --shadow: 2px 2px 4px rgba(0,0,0,0.3);
            --primary: #292524;
            --accent: #22c55e;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f5f5f4;
            color: #444;
            user-select: none;
            overflow: hidden; /* 防止移动端滚动 */
        }

        /* --- 布局容器 --- */
        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            width: min(95vw, 500px);
            position: relative;
        }

        /* --- 顶部状态栏 --- */
        .header {
            display: flex;
            justify-content: space-between;
            width: 100%;
            align-items: center;
            height: 40px;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 20px;
            background: #f0f0f0;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s;
        }
        .status-badge.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transform: scale(1.05);
        }
        .mini-stone {
            width: 12px; height: 12px; border-radius: 50%;
        }
        .mini-stone.black { background: #000; }
        .mini-stone.white { background: #fff; border: 1px solid #ccc; }

        /* --- 棋盘区域 --- */
        .board-wrapper {
            padding: 8px;
            background: var(--board-bg);
            border-radius: 4px;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.2);
            border: 5px solid var(--board-border);
            position: relative;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            width: min(88vw, 420px);
            height: min(88vw, 420px);
            position: relative;
        }

        .cell {
            position: relative;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* 网格线 */
        .cell::before { content: ''; position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background: var(--line-color); z-index: 0; }
        .cell::after { content: ''; position: absolute; left: 50%; top: 0; height: 100%; width: 1px; background: var(--line-color); z-index: 0; }
        /* 星位 */
        .star-point { position: absolute; width: 6px; height: 6px; background: #333; border-radius: 50%; z-index: 1; }

        /* 棋子样式 */
        .stone {
            width: 85%; height: 85%; border-radius: 50%; z-index: 2;
            box-shadow: var(--shadow);
            transform: scale(0);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .stone.show { transform: scale(1); }
        .stone.black { background: var(--black-stone); }
        .stone.white { background: var(--white-stone); }
        
        /* 最后一手标记 */
        .stone.last-move::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 30%; height: 30%;
            background: rgba(255,0,0,0.6); border-radius: 50%;
        }
        .stone.winning { box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.6); }

        /* 提示标记 */
        .hint-mark {
            position: absolute; width: 40%; height: 40%;
            background: rgba(34, 197, 94, 0.6);
            border-radius: 50%; z-index: 3;
            animation: pulse 1s infinite;
            pointer-events: none;
        }
        @keyframes pulse { 0% { transform: scale(0.8); opacity: 0.8; } 100% { transform: scale(1.2); opacity: 0; } }

        /* --- 底部工具栏 --- */
        .toolbar {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            width: 100%;
        }

        .btn {
            background: white; border: 1px solid #ddd;
            color: #444; padding: 10px 0;
            border-radius: 8px; cursor: pointer;
            font-size: 0.85rem; font-weight: 600;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            gap: 4px; transition: all 0.2s;
        }
        .btn:hover { background: #f9f9f9; border-color: #ccc; }
        .btn:active { transform: scale(0.96); }
        .btn svg { width: 20px; height: 20px; stroke-width: 2px; }
        
        .btn.primary { background: var(--primary); color: white; border: none; }
        .btn.primary:hover { background: #44403c; }

        /* --- 复盘控制条 (默认隐藏) --- */
        .replay-controls {
            display: none; /* flex when active */
            width: 100%; justify-content: space-between;
            background: #f0f0f0; padding: 8px; border-radius: 8px;
        }
        .replay-btn {
            background: none; border: none; cursor: pointer; padding: 8px;
            color: #444; border-radius: 4px;
        }
        .replay-btn:hover { background: rgba(0,0,0,0.1); }
        .replay-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        /* --- 模态框 (设置/结束) --- */
        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 100;
            display: flex; justify-content: center; align-items: center;
            border-radius: 16px;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
        }
        .modal-overlay.open { opacity: 1; pointer-events: auto; }
        
        .modal {
            background: white; padding: 2rem; border-radius: 12px;
            width: 80%; text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            transform: translateY(20px); transition: transform 0.3s;
        }
        .modal-overlay.open .modal { transform: translateY(0); }
        
        .modal h2 { margin-top: 0; color: var(--primary); }
        .mode-select { display: flex; gap: 10px; margin: 20px 0; justify-content: center; }
        .mode-btn {
            flex: 1; padding: 12px; border: 2px solid #eee;
            border-radius: 8px; background: white; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; gap: 5px;
        }
        .mode-btn.selected { border-color: var(--primary); background: #fafafa; }
        .mode-btn svg { width: 24px; height: 24px; }

    </style>
</head>
<body>

    <div class="card">
        <!-- 顶部信息 -->
        <div class="header">
            <div class="status-badge" id="badge-black">
                <div class="mini-stone black"></div> <span>黑方</span>
            </div>
            <div style="font-weight:bold; color:#ccc">VS</div>
            <div class="status-badge" id="badge-white">
                <div class="mini-stone white"></div> <span>白方</span>
            </div>
        </div>

        <!-- 棋盘 -->
        <div class="board-wrapper">
            <div id="board"></div>
        </div>

        <!-- 复盘控制条 -->
        <div class="replay-controls" id="replayBar">
            <button class="replay-btn" onclick="game.replayJump('start')">⏮</button>
            <button class="replay-btn" onclick="game.replayStep(-1)">◀ 上一步</button>
            <span style="font-size:0.9rem; line-height: 32px;" id="replayStepInfo">0 / 0</span>
            <button class="replay-btn" onclick="game.replayStep(1)">下一步 ▶</button>
            <button class="replay-btn" onclick="game.replayJump('end')">⏭</button>
            <button class="replay-btn" style="color:red" onclick="game.exitReplay()">退出</button>
        </div>

        <!-- 游戏工具栏 -->
        <div class="toolbar" id="gameToolbar">
            <button class="btn" onclick="game.showSettings()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74-2.74L3 12"/></svg>
                重开
            </button>
            <button class="btn" onclick="game.undo()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 10h10a8 8 0 0 1 8 8v2M3 10l6 6M3 10l6-6"/></svg>
                悔棋
            </button>
            <button class="btn" onclick="game.getHint()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M9 18h6M10 22h4M12 2v1M12 15a5 5 0 0 1-5-5c0-3 4-5 5-5s5 2 5 5a5 5 0 0 1-5 5z"/></svg>
                提示
            </button>
            <button class="btn" onclick="game.enterReplayMode()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                复盘
            </button>
        </div>
        
        <div style="text-align:center; font-size:0.8rem; color:#999; height:1rem;" id="msgArea"></div>
    </div>

    <!-- 设置模态框 -->
    <div class="modal-overlay open" id="settingsModal">
        <div class="modal">
            <h2>新游戏设置</h2>
            <p>选择对战模式</p>
            <div class="mode-select">
                <button class="mode-btn selected" onclick="selectMode('pve')" id="btn-pve">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><path d="M12 7v4"/></svg>
                    人机对战
                </button>
                <button class="mode-btn" onclick="selectMode('pvp')" id="btn-pvp">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                    双人对战
                </button>
            </div>
            
            <div id="side-selector">
                <p>选择执子</p>
                <div class="mode-select">
                    <button class="mode-btn selected" onclick="selectSide('black')" id="btn-black">
                        <div class="mini-stone black" style="width:20px;height:20px;margin:0 auto"></div>
                        执黑 (先手)
                    </button>
                    <button class="mode-btn" onclick="selectSide('white')" id="btn-white">
                        <div class="mini-stone white" style="width:20px;height:20px;margin:0 auto"></div>
                        执白 (后手)
                    </button>
                </div>
            </div>

            <button class="btn primary" style="width:100%" onclick="game.startGame()">开始游戏</button>
        </div>
    </div>

    <script>
        // 全局配置变量
        let config = {
            mode: 'pve', // pve or pvp
            mySide: 'black' // black or white
        };

        function selectMode(mode) {
            config.mode = mode;
            document.getElementById('btn-pve').classList.toggle('selected', mode === 'pve');
            document.getElementById('btn-pvp').classList.toggle('selected', mode === 'pvp');
            document.getElementById('side-selector').style.display = mode === 'pve' ? 'block' : 'none';
        }

        function selectSide(side) {
            config.mySide = side;
            document.getElementById('btn-black').classList.toggle('selected', side === 'black');
            document.getElementById('btn-white').classList.toggle('selected', side === 'white');
        }

        class GobangGame {
            constructor() {
                this.BOARD_SIZE = 15;
                this.boardData = [];
                this.history = []; // 记录每一步 {r, c, player}
                this.currentPlayer = 'black';
                this.winner = null;
                this.isAiThinking = false;
                this.isReplaying = false;
                this.replayIndex = 0;

                this.domBoard = document.getElementById('board');
                this.msgEl = document.getElementById('msgArea');
                
                this.initBoardUI();
            }

            initBoardUI() {
                this.domBoard.innerHTML = '';
                for (let r = 0; r < this.BOARD_SIZE; r++) {
                    for (let c = 0; c < this.BOARD_SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.r = r;
                        cell.dataset.c = c;
                        
                        if ((r === 3 || r === 11 || r === 7) && (c === 3 || c === 11 || c === 7)) {
                            const star = document.createElement('div');
                            star.className = 'star-point';
                            cell.appendChild(star);
                        }

                        cell.addEventListener('click', () => this.handleInput(r, c));
                        this.domBoard.appendChild(cell);
                    }
                }
            }

            showSettings() {
                document.getElementById('settingsModal').classList.add('open');
            }

            startGame() {
                document.getElementById('settingsModal').classList.remove('open');
                this.reset();
                
                // 如果是人机且玩家选白，AI (黑) 先走
                if (config.mode === 'pve' && config.mySide === 'white') {
                    this.handleMove(7, 7, true); // AI 天元开局
                }
            }

            reset() {
                this.boardData = Array(this.BOARD_SIZE).fill(null).map(() => Array(this.BOARD_SIZE).fill(null));
                this.history = [];
                this.currentPlayer = 'black';
                this.winner = null;
                this.isAiThinking = false;
                this.exitReplay(); // 确保退出复盘模式
                
                // 清理UI
                document.querySelectorAll('.stone').forEach(el => el.remove());
                document.querySelectorAll('.hint-mark').forEach(el => el.remove());
                
                this.updateStatus();
                this.msgEl.textContent = "游戏开始";
            }

            handleInput(r, c) {
                if (this.isReplaying) return; // 复盘模式禁止落子
                if (this.winner || this.boardData[r][c] || this.isAiThinking) return;
                
                // PvE模式下，如果轮到AI走，玩家不能点
                if (config.mode === 'pve' && this.currentPlayer !== config.mySide) return;

                this.handleMove(r, c);
            }

            handleMove(r, c, isAi = false) {
                // 1. 逻辑落子
                this.boardData[r][c] = this.currentPlayer;
                this.history.push({r, c, player: this.currentPlayer});
                
                // 2. 视觉落子
                this.renderStone(r, c, this.currentPlayer);
                this.clearHint();

                // 3. 检查胜利
                const winLine = this.checkWin(r, c, this.currentPlayer);
                if (winLine) {
                    this.winner = this.currentPlayer;
                    this.highlightWin(winLine);
                    this.msgEl.textContent = `${this.winner === 'black' ? '黑方' : '白方'} 获胜！`;
                    this.updateStatus();
                    return;
                }

                // 4. 切换回合
                this.currentPlayer = this.currentPlayer === 'black' ? 'white' : 'black';
                this.updateStatus();

                // 5. 触发AI (仅在PvE且游戏未结束)
                if (config.mode === 'pve' && !this.winner && this.currentPlayer !== config.mySide) {
                    this.isAiThinking = true;
                    this.msgEl.textContent = "AI 思考中...";
                    setTimeout(() => this.aiTurn(), 600);
                }
            }

            renderStone(r, c, player) {
                const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
                const stone = document.createElement('div');
                stone.className = `stone ${player}`;
                
                // 移除旧的last-move标记
                document.querySelectorAll('.last-move').forEach(el => el.classList.remove('last-move'));
                stone.classList.add('last-move');
                
                cell.appendChild(stone);
                stone.offsetHeight; // Trigger reflow
                stone.classList.add('show');
            }

            undo() {
                if (this.isReplaying || this.winner || this.isAiThinking) return;
                if (this.history.length === 0) return;

                // 定义回退步数
                let steps = 1;
                if (config.mode === 'pve') {
                    // 如果是人机，且轮到人走，说明AI刚走完，或者人刚走完还没轮到AI(不可能，因为AI是自动的)
                    // 通常情况是：人下 -> AI下 -> (现在轮到人)。所以悔棋要悔2步。
                    // 除非是玩家执白，刚开局AI下了一步，此时只能悔1步。
                    if (this.history.length === 1 && config.mySide === 'white') {
                        steps = 1; // 特殊情况：只悔AI的第一手
                    } else {
                        steps = 2;
                    }
                }

                for (let i = 0; i < steps; i++) {
                    if (this.history.length === 0) break;
                    const last = this.history.pop();
                    this.boardData[last.r][last.c] = null;
                    const cell = document.querySelector(`.cell[data-r="${last.r}"][data-c="${last.c}"]`);
                    const stone = cell.querySelector('.stone');
                    if (stone) stone.remove();
                    
                    // 恢复上一回合的执子者
                    this.currentPlayer = last.player;
                }
                
                // 恢复 last-move 标记
                if (this.history.length > 0) {
                    const last = this.history[this.history.length - 1];
                    const cell = document.querySelector(`.cell[data-r="${last.r}"][data-c="${last.c}"]`);
                    cell.querySelector('.stone')?.classList.add('last-move');
                }

                this.updateStatus();
                this.msgEl.textContent = "已悔棋";
            }

            getHint() {
                if (this.winner || this.isReplaying) return;
                if (config.mode === 'pve' && this.currentPlayer !== config.mySide) return;

                this.clearHint();
                const move = this.calculateBestMove(this.currentPlayer);
                if (move) {
                    const cell = document.querySelector(`.cell[data-r="${move[0]}"][data-c="${move[1]}"]`);
                    const hint = document.createElement('div');
                    hint.className = 'hint-mark';
                    cell.appendChild(hint);
                }
            }

            clearHint() {
                document.querySelectorAll('.hint-mark').forEach(el => el.remove());
            }

            // --- 复盘系统 ---
            enterReplayMode() {
                if (this.history.length === 0) {
                    this.msgEl.textContent = "没有对局记录，无法复盘";
                    return;
                }
                this.isReplaying = true;
                this.replayIndex = this.history.length; // 默认停在最后
                
                document.getElementById('gameToolbar').style.display = 'none';
                document.getElementById('replayBar').style.display = 'flex';
                this.msgEl.textContent = "进入复盘模式";
                
                this.renderReplayBoard();
            }

            exitReplay() {
                this.isReplaying = false;
                document.getElementById('gameToolbar').style.display = 'grid';
                document.getElementById('replayBar').style.display = 'none';
                
                // 恢复当前棋盘状态
                this.boardData = Array(this.BOARD_SIZE).fill(null).map(() => Array(this.BOARD_SIZE).fill(null));
                document.querySelectorAll('.stone').forEach(el => el.remove());
                
                // 重新渲染所有历史
                this.history.forEach(move => {
                    this.boardData[move.r][move.c] = move.player;
                    this.renderStone(move.r, move.c, move.player);
                });
                
                if (this.winner) {
                    const last = this.history[this.history.length-1];
                    const winLine = this.checkWin(last.r, last.c, last.player);
                    if(winLine) this.highlightWin(winLine);
                }
            }

            replayStep(direction) {
                const newIndex = this.replayIndex + direction;
                if (newIndex < 0 || newIndex > this.history.length) return;
                
                this.replayIndex = newIndex;
                this.renderReplayBoard();
            }

            replayJump(target) {
                if (target === 'start') this.replayIndex = 0;
                if (target === 'end') this.replayIndex = this.history.length;
                this.renderReplayBoard();
            }

            renderReplayBoard() {
                // 清空棋盘
                document.querySelectorAll('.stone').forEach(el => el.remove());
                document.getElementById('replayStepInfo').textContent = `${this.replayIndex} / ${this.history.length}`;

                // 渲染到 replayIndex 为止
                for (let i = 0; i < this.replayIndex; i++) {
                    const move = this.history[i];
                    this.renderStone(move.r, move.c, move.player);
                }
            }

            // --- AI 核心 (复用之前的逻辑) ---
            aiTurn() {
                const move = this.calculateBestMove(this.currentPlayer);
                if (move) {
                    this.handleMove(move[0], move[1], true);
                }
                this.isAiThinking = false;
            }

            calculateBestMove(player) {
                const aiPlayer = player;
                const opponent = player === 'black' ? 'white' : 'black';
                let bestScore = -Infinity;
                let bestMoves = [];

                // 评分权重
                const weights = { win: 100000, blockWin: 50000, open4: 10000, blockOpen4: 8000, open3: 1000, center: 10 };

                for (let r = 0; r < this.BOARD_SIZE; r++) {
                    for (let c = 0; c < this.BOARD_SIZE; c++) {
                        if (this.boardData[r][c]) continue;
                        let score = 0;
                        const centerDist = Math.abs(r - 7) + Math.abs(c - 7);
                        score += (14 - centerDist) * weights.center;

                        const attack = this.evaluatePoint(r, c, aiPlayer);
                        const defense = this.evaluatePoint(r, c, opponent);

                        if (attack >= weights.win) score += attack * 1.2;
                        else if (defense >= weights.win) score += defense * 1.1;
                        else score += attack + defense;

                        if (score > bestScore) { bestScore = score; bestMoves = [[r, c]]; }
                        else if (score === bestScore) { bestMoves.push([r, c]); }
                    }
                }
                return bestMoves.length > 0 ? bestMoves[Math.floor(Math.random() * bestMoves.length)] : null;
            }

            evaluatePoint(r, c, player) {
                let total = 0;
                const dirs = [[0,1],[1,0],[1,1],[1,-1]];
                for(let d of dirs) {
                    let count = 1, blocked = 0;
                    for(let i=1; ;i++) {
                        let nr=r+d[0]*i, nc=c+d[1]*i;
                        if(nr<0||nr>=15||nc<0||nc>=15) { blocked++; break; }
                        if(!this.boardData[nr][nc]) break;
                        if(this.boardData[nr][nc]!==player) { blocked++; break; }
                        count++;
                    }
                    for(let i=1; ;i++) {
                        let nr=r-d[0]*i, nc=c-d[1]*i;
                        if(nr<0||nr>=15||nc<0||nc>=15) { blocked++; break; }
                        if(!this.boardData[nr][nc]) break;
                        if(this.boardData[nr][nc]!==player) { blocked++; break; }
                        count++;
                    }
                    if(count>=5) total+=100000;
                    else if(count===4 && blocked===0) total+=10000;
                    else if(count===4 && blocked===1) total+=2000;
                    else if(count===3 && blocked===0) total+=1000;
                }
                return total;
            }

            checkWin(row, col, player) {
                const directions = [[[0, 1], [0, -1]], [[1, 0], [-1, 0]], [[1, 1], [-1, -1]], [[1, -1], [-1, 1]]];
                for (const direction of directions) {
                    let line = [[row, col]];
                    for (const [dx, dy] of direction) {
                        let r = row + dx, c = col + dy;
                        while (r >= 0 && r < 15 && c >= 0 && c < 15 && this.boardData[r][c] === player) {
                            line.push([r, c]); r += dx; c += dy;
                        }
                    }
                    if (line.length >= 5) return line;
                }
                return null;
            }

            highlightWin(line) {
                line.forEach(([r, c]) => {
                    const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"] .stone`);
                    if (cell) cell.classList.add('winning');
                });
            }

            updateStatus() {
                document.getElementById('badge-black').classList.toggle('active', this.currentPlayer === 'black');
                document.getElementById('badge-white').classList.toggle('active', this.currentPlayer === 'white');
            }
        }

        const game = new GobangGame();
    </script>
</body>
</html>
